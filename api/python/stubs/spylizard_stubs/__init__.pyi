"""This is the python binding for the sparselizard c++ library"""
from __future__ import annotations
import spylizard
import typing

__all__ = [
    "abs",
    "acos",
    "adapt",
    "alladapt",
    "allgather",
    "allpartition",
    "andpositive",
    "array1x1",
    "array1x2",
    "array1x3",
    "array2x1",
    "array2x2",
    "array2x3",
    "array3x1",
    "array3x2",
    "array3x3",
    "asin",
    "atan",
    "barrier",
    "broadcast",
    "comp",
    "compx",
    "compy",
    "compz",
    "continuitycondition",
    "cos",
    "count",
    "crossproduct",
    "curl",
    "dbtoneper",
    "densemat",
    "determinant",
    "div",
    "dof",
    "doubledotproduct",
    "dt",
    "dtdt",
    "dtdtdt",
    "dtdtdtdt",
    "dx",
    "dy",
    "dz",
    "eigenvalue",
    "entry",
    "exchange",
    "exp",
    "expression",
    "eye",
    "field",
    "fieldorder",
    "finalize",
    "formulation",
    "gather",
    "genalpha",
    "getharmonic",
    "getmaxnumthreads",
    "getpi",
    "getrandom",
    "getrank",
    "getsubversion",
    "gettime",
    "gettotalforce",
    "getversion",
    "getversionname",
    "grad",
    "greenlagrangestrain",
    "grouptimesteps",
    "ifpositive",
    "impliciteuler",
    "indexmat",
    "initialize",
    "integral",
    "integration",
    "inverse",
    "isavailable",
    "isdefined",
    "isempty",
    "isinside",
    "istouching",
    "linspace",
    "loadshape",
    "loadvector",
    "log10",
    "logspace",
    "makeharmonic",
    "mat",
    "max",
    "mesh",
    "meshsize",
    "min",
    "mod",
    "moveharmonic",
    "norm",
    "normal",
    "on",
    "orpositive",
    "parameter",
    "periodicitycondition",
    "port",
    "pow",
    "predefinedacousticradiation",
    "predefinedacoustics",
    "predefinedacousticstructureinteraction",
    "predefinedadvectiondiffusion",
    "predefineddiffusion",
    "predefinedelasticity",
    "predefinedelectrostaticforce",
    "predefinedmagnetostaticforce",
    "predefinednavierstokes",
    "predefinedstabilization",
    "predefinedstokes",
    "printtotalforce",
    "printvector",
    "printversion",
    "receive",
    "scatter",
    "scatterwrite",
    "selectall",
    "selectintersection",
    "selectunion",
    "send",
    "setaxisymmetry",
    "setdata",
    "setfundamentalfrequency",
    "setmaxnumthreads",
    "setphysicalregionshift",
    "settime",
    "settimederivative",
    "shape",
    "sin",
    "solve",
    "spanningtree",
    "spline",
    "sqrt",
    "strain",
    "sum",
    "t",
    "tan",
    "tangent",
    "tf",
    "trace",
    "transpose",
    "universe",
    "vec",
    "vectorfieldselect",
    "vonmises",
    "wallclock",
    "writeshapefunctions",
    "writevector",
    "zienkiewiczzhu"
]


class densemat():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, input: typing.List[densemat]) -> None: ...
    @typing.overload
    def __init__(self, numberofrows: int, numberofcolumns: int) -> None: ...
    @typing.overload
    def __init__(self, numberofrows: int, numberofcolumns: int, init: float, step: float) -> None: ...
    @typing.overload
    def __init__(self, numberofrows: int, numberofcolumns: int, initvalue: float) -> None: ...
    @typing.overload
    def __init__(self, numberofrows: int, numberofcolumns: int, valvec: typing.List[float]) -> None: ...
    def count(self) -> int: ...
    def countcolumns(self) -> int: ...
    def countrows(self) -> int: ...
    def print(self) -> None: ...
    def printsize(self) -> None: ...
    pass
class eigenvalue():
    @typing.overload
    def __init__(self, A: mat) -> None: ...
    @typing.overload
    def __init__(self, A: mat, B: mat) -> None: ...
    @typing.overload
    def __init__(self, K: mat, C: mat, M: mat) -> None: ...
    @typing.overload
    def __init__(self, inmats: typing.List[mat]) -> None: ...
    def compute(self, numeigenvaluestocompute: int, targeteigenvaluemagnitude: float = 0.0) -> None: ...
    def count(self) -> int: ...
    def geteigenvalueimaginarypart(self) -> typing.List[float]: ...
    def geteigenvaluerealpart(self) -> typing.List[float]: ...
    def geteigenvectorimaginarypart(self) -> typing.List[vec]: ...
    def geteigenvectorrealpart(self) -> typing.List[vec]: ...
    def printeigenfrequencies(self) -> None: ...
    def printeigenvalues(self) -> None: ...
    pass
class expression():
    @typing.overload
    def __add__(self, arg0: expression) -> expression: ...
    @typing.overload
    def __add__(self, arg0: field) -> expression: ...
    @typing.overload
    def __add__(self, arg0: float) -> expression: ...
    @typing.overload
    def __add__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __add__(self, arg0: port) -> expression: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, condexpr: expression, exprtrue: expression, exprfalse: expression) -> None: ...
    @typing.overload
    def __init__(self, input: field) -> None: ...
    @typing.overload
    def __init__(self, input: float) -> None: ...
    @typing.overload
    def __init__(self, input: parameter) -> None: ...
    @typing.overload
    def __init__(self, input: port) -> None: ...
    @typing.overload
    def __init__(self, input: typing.List[typing.List[expression]]) -> None: ...
    @typing.overload
    def __init__(self, numrows: int, numcols: int, exprs: typing.List[expression]) -> None: ...
    @typing.overload
    def __init__(self, pos: typing.List[float], exprs: typing.List[expression], tocompare: expression) -> None: ...
    @typing.overload
    def __init__(self, spl: spline, arg: expression) -> None: ...
    @typing.overload
    def __mul__(self, arg0: expression) -> expression: ...
    @typing.overload
    def __mul__(self, arg0: field) -> expression: ...
    @typing.overload
    def __mul__(self, arg0: float) -> expression: ...
    @typing.overload
    def __mul__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __mul__(self, arg0: port) -> expression: ...
    def __neg__(self) -> expression: ...
    def __pos__(self) -> expression: ...
    @typing.overload
    def __radd__(self, arg0: field) -> expression: ...
    @typing.overload
    def __radd__(self, arg0: float) -> expression: ...
    @typing.overload
    def __radd__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __radd__(self, arg0: port) -> expression: ...
    @typing.overload
    def __rmul__(self, arg0: field) -> expression: ...
    @typing.overload
    def __rmul__(self, arg0: float) -> expression: ...
    @typing.overload
    def __rmul__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __rmul__(self, arg0: port) -> expression: ...
    @typing.overload
    def __rsub__(self, arg0: field) -> expression: ...
    @typing.overload
    def __rsub__(self, arg0: float) -> expression: ...
    @typing.overload
    def __rsub__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __rsub__(self, arg0: port) -> expression: ...
    @typing.overload
    def __rtruediv__(self, arg0: field) -> expression: ...
    @typing.overload
    def __rtruediv__(self, arg0: float) -> expression: ...
    @typing.overload
    def __rtruediv__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __rtruediv__(self, arg0: port) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: expression) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: field) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: float) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: port) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: expression) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: field) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: port) -> expression: ...
    def at(self, row: int, col: int) -> expression: ...
    def atbarycenter(self, physreg: int, onefield: field) -> vec: ...
    def countcolumns(self) -> int: ...
    def countrows(self) -> int: ...
    def evaluate(self) -> float: ...
    def getcolumn(self, colnum: int) -> expression: ...
    def getrow(self, rownum: int) -> expression: ...
    @typing.overload
    def integrate(self, physreg: int, integrationorder: int) -> float: ...
    @typing.overload
    def integrate(self, physreg: int, meshdeform: expression, integrationorder: int) -> float: ...
    @typing.overload
    def interpolate(self, physreg: int, meshdeform: expression, xyzcoord: list, interpolated: list, isfound: list) -> None: ...
    @typing.overload
    def interpolate(self, physreg: int, meshdeform: expression, xyzcoord: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def interpolate(self, physreg: int, xyzcoord: list, interpolated: list, isfound: list) -> None: ...
    @typing.overload
    def interpolate(self, physreg: int, xyzcoord: typing.List[float]) -> typing.List[float]: ...
    def isscalar(self) -> bool: ...
    def iszero(self) -> bool: ...
    @typing.overload
    def max(self, physreg: int, meshdeform: expression, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def max(self, physreg: int, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def min(self, physreg: int, meshdeform: expression, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def min(self, physreg: int, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    def print(self) -> None: ...
    def reordercolumns(self, neworder: typing.List[int]) -> None: ...
    def reorderrows(self, neworder: typing.List[int]) -> None: ...
    def resize(self, numrows: int, numcols: int) -> expression: ...
    def reuseit(self, istobereused: bool = True) -> None: ...
    def rotate(self, ax: float, ay: float, az: float, leftop: str = 'default', rightop: str = 'default') -> None: ...
    def streamline(self, physreg: int, filename: str, startcoords: typing.List[float], stepsize: float, downstreamonly: bool = False) -> None: ...
    @typing.overload
    def write(self, physreg: int, filename: str, lagrangeorder: int, numtimesteps: int = -1) -> None: ...
    @typing.overload
    def write(self, physreg: int, meshdeform: expression, filename: str, lagrangeorder: int, numtimesteps: int = -1) -> None: ...
    @typing.overload
    def write(self, physreg: int, numfftharms: int, filename: str, lagrangeorder: int) -> None: ...
    @typing.overload
    def write(self, physreg: int, numfftharms: int, meshdeform: expression, filename: str, lagrangeorder: int) -> None: ...
    pass
class field():
    @typing.overload
    def __add__(self, arg0: field) -> expression: ...
    @typing.overload
    def __add__(self, arg0: float) -> expression: ...
    @typing.overload
    def __add__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fieldtypename: str) -> None: ...
    @typing.overload
    def __init__(self, fieldtypename: str, harmonicnumbers: typing.List[int]) -> None: ...
    @typing.overload
    def __init__(self, fieldtypename: str, harmonicnumbers: typing.List[int], spantree: spanningtree) -> None: ...
    @typing.overload
    def __init__(self, fieldtypename: str, spantree: spanningtree) -> None: ...
    @typing.overload
    def __mul__(self, arg0: field) -> expression: ...
    @typing.overload
    def __mul__(self, arg0: float) -> expression: ...
    @typing.overload
    def __mul__(self, arg0: parameter) -> expression: ...
    def __neg__(self) -> expression: ...
    def __pos__(self) -> expression: ...
    @typing.overload
    def __radd__(self, arg0: float) -> expression: ...
    @typing.overload
    def __radd__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __rmul__(self, arg0: float) -> expression: ...
    @typing.overload
    def __rmul__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __rsub__(self, arg0: float) -> expression: ...
    @typing.overload
    def __rsub__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __rtruediv__(self, arg0: float) -> expression: ...
    @typing.overload
    def __rtruediv__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: field) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: float) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: field) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: parameter) -> expression: ...
    def atbarycenter(self, physreg: int, onefield: field) -> vec: ...
    def automaticupdate(self, updateit: bool) -> None: ...
    def comp(self, component: int) -> field: ...
    def compx(self) -> field: ...
    def compy(self) -> field: ...
    def compz(self) -> field: ...
    def cos(self, freqindex: int) -> field: ...
    def countcomponents(self) -> int: ...
    def getharmonics(self) -> typing.List[int]: ...
    def getnodalvalues(self, nodenumbers: indexmat) -> densemat: ...
    @typing.overload
    def harmonic(self, harmonicnumber: int) -> field: ...
    @typing.overload
    def harmonic(self, harmonicnumbers: typing.List[int]) -> field: ...
    @typing.overload
    def integrate(self, physreg: int, integrationorder: int) -> float: ...
    @typing.overload
    def integrate(self, physreg: int, meshdeform: expression, integrationorder: int) -> float: ...
    @typing.overload
    def interpolate(self, physreg: int, meshdeform: expression, xyzcoord: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def interpolate(self, physreg: int, meshdeform: expression, xyzcoord: typing.List[float], interpolated: typing.List[float], isfound: typing.List[bool]) -> None: ...
    @typing.overload
    def interpolate(self, physreg: int, xyzcoord: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def interpolate(self, physreg: int, xyzcoord: typing.List[float], interpolated: typing.List[float], isfound: typing.List[bool]) -> None: ...
    def loadraw(self, filename: str, isbinary: bool = False) -> typing.List[float]: ...
    @typing.overload
    def max(self, physreg: int, meshdeform: expression, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def max(self, physreg: int, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def min(self, physreg: int, meshdeform: expression, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def min(self, physreg: int, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    def noautomaticupdate(self) -> None: ...
    def print(self) -> None: ...
    def printharmonics(self) -> None: ...
    def printvalues(self, databoundsonly: bool) -> None: ...
    def setcohomologysources(self, cutphysregs: typing.List[int], cutvalues: typing.List[float]) -> None: ...
    def setconditionalconstraint(self, physreg: int, condexpr: expression, valexpr: expression) -> None: ...
    @typing.overload
    def setconstraint(self, physreg: int) -> None: ...
    @typing.overload
    def setconstraint(self, physreg: int, input: expression, extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setconstraint(self, physreg: int, input: typing.List[expression], extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setconstraint(self, physreg: int, meshdeform: expression, input: expression, extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setconstraint(self, physreg: int, meshdeform: expression, input: typing.List[expression], extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setconstraint(self, physreg: int, numfftharms: int, input: expression, extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setconstraint(self, physreg: int, numfftharms: int, meshdeform: expression, input: expression, extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setdata(self, physreg: int, myvec: vec, op: str = 'set') -> None: ...
    @typing.overload
    def setdata(self, physreg: int, myvec: vectorfieldselect, op: str = 'set') -> None: ...
    def setgauge(self, physreg: int) -> None: ...
    def setname(self, name: str) -> None: ...
    def setnodalvalues(self, nodenumbers: indexmat, values: densemat) -> None: ...
    @typing.overload
    def setorder(self, criterion: expression, loworder: int, highorder: int) -> None: ...
    @typing.overload
    def setorder(self, physreg: int, interpolorder: int) -> None: ...
    @typing.overload
    def setorder(self, targeterror: float, loworder: int, highorder: int, absthres: float) -> None: ...
    def setport(self, physreg: int, primal: port, dual: port) -> None: ...
    def setupdateaccuracy(self, extraintegrationorder: int) -> None: ...
    @typing.overload
    def setvalue(self, physreg: int) -> None: ...
    @typing.overload
    def setvalue(self, physreg: int, input: expression, extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setvalue(self, physreg: int, meshdeform: expression, input: expression, extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setvalue(self, physreg: int, numfftharms: int, input: expression, extraintegrationdegree: int = 0) -> None: ...
    @typing.overload
    def setvalue(self, physreg: int, numfftharms: int, meshdeform: expression, input: expression, extraintegrationdegree: int = 0) -> None: ...
    def sin(self, freqindex: int) -> field: ...
    @typing.overload
    def write(self, physreg: int, filename: str, lagrangeorder: int, numtimesteps: int = -1) -> None: ...
    @typing.overload
    def write(self, physreg: int, meshdeform: expression, filename: str, lagrangeorder: int, numtimesteps: int = -1) -> None: ...
    @typing.overload
    def write(self, physreg: int, numfftharms: int, filename: str, lagrangeorder: int) -> None: ...
    @typing.overload
    def write(self, physreg: int, numfftharms: int, meshdeform: expression, filename: str, lagrangeorder: int) -> None: ...
    def writeraw(self, physreg: int, filename: str, isbinary: bool = False, extradata: typing.List[float] = []) -> None: ...
    pass
class formulation():
    def A(self, keepfragments: bool = False) -> mat: ...
    def C(self, keepfragments: bool = False) -> mat: ...
    def K(self, keepfragments: bool = False) -> mat: ...
    def M(self, keepfragments: bool = False) -> mat: ...
    @typing.overload
    def __iadd__(self, expression: expression) -> formulation: ...
    @typing.overload
    def __iadd__(self, integrationobject: integration) -> formulation: ...
    @typing.overload
    def __iadd__(self, integrationobject: typing.List[integration]) -> formulation: ...
    def __init__(self) -> None: ...
    def allcountdofs(self) -> int: ...
    @typing.overload
    def allsolve(self, formulterms: typing.List[int], physicalterms: typing.List[typing.List[int]], artificialterms: typing.List[typing.List[int]], relrestol: float, maxnumit: int, soltype: str = 'lu', verbosity: int = 1) -> typing.List[float]: ...
    @typing.overload
    def allsolve(self, relrestol: float, maxnumit: int, soltype: str = 'lu', verbosity: int = 1) -> typing.List[float]: ...
    def b(self, keepvector: bool = False, dirichletandportupdate: bool = True) -> vec: ...
    def countdofs(self) -> int: ...
    @typing.overload
    def generate(self) -> None: ...
    @typing.overload
    def generate(self, contributionnumber: int) -> None: ...
    @typing.overload
    def generate(self, contributionnumbers: typing.List[int]) -> None: ...
    def generatedampingmatrix(self) -> None: ...
    def generatemassmatrix(self) -> None: ...
    def generaterhs(self) -> None: ...
    def generatestiffnessmatrix(self) -> None: ...
    def getmatrix(self, KCM: int, keepfragments: bool = False, additionalconstraints: typing.List[indexmat] = []) -> mat: ...
    def rhs(self, keepvector: bool = False, dirichletandportupdate: bool = True) -> vec: ...
    def solve(self, soltype: str = 'lu', diagscaling: bool = False, blockstoconsider: typing.List[int] = [-1]) -> None: ...
    pass
class genalpha():
    def __init__(self, formul: formulation, dtxinit: vec, dtdtxinit: vec, verbosity: int = 3, isrhskcmconstant: typing.List[bool] = [False, False, False, False]) -> None: ...
    def count(self) -> int: ...
    def gettimederivative(self) -> typing.List[vec]: ...
    def gettimes(self) -> typing.List[float]: ...
    def gettimestep(self) -> float: ...
    @typing.overload
    def next(self, timestep: float) -> None: ...
    @typing.overload
    def next(self, timestep: float, maxnumnlit: int) -> int: ...
    def postsolve(self, formuls: typing.List[formulation]) -> None: ...
    def presolve(self, formuls: typing.List[formulation]) -> None: ...
    def setadaptivity(self, tol: float, mints: float, maxts: float, reffact: float = 0.5, coarfact: float = 2.0, coarthres: float = 0.5) -> None: ...
    @typing.overload
    def setparameter(self, b: float, g: float, af: float, am: float) -> None: ...
    @typing.overload
    def setparameter(self, rinf: float) -> None: ...
    def settimederivative(self, sol: typing.List[vec]) -> None: ...
    def settimestep(self, timestep: float) -> None: ...
    def settolerance(self, nltol: float) -> None: ...
    def setverbosity(self, verbosity: int) -> None: ...
    pass
class impliciteuler():
    def __init__(self, formul: formulation, dtxinit: vec, verbosity: int = 3, isrhskcconstant: typing.List[bool] = [False, False, False]) -> None: ...
    def count(self) -> int: ...
    def gettimederivative(self) -> vec: ...
    def gettimes(self) -> typing.List[float]: ...
    def gettimestep(self) -> float: ...
    @typing.overload
    def next(self, timestep: float) -> None: ...
    @typing.overload
    def next(self, timestep: float, maxnumnlit: int) -> int: ...
    def postsolve(self, formuls: typing.List[formulation]) -> None: ...
    def presolve(self, formuls: typing.List[formulation]) -> None: ...
    def setadaptivity(self, tol: float, mints: float, maxts: float, reffact: float = 0.5, coarfact: float = 2.0, coarthres: float = 0.5) -> None: ...
    def setrelaxationfactor(self, relaxfact: float) -> None: ...
    def settimederivative(self, sol: vec) -> None: ...
    def settimestep(self, timestep: float) -> None: ...
    def settolerance(self, nltol: float) -> None: ...
    def setverbosity(self, verbosity: int) -> None: ...
    pass
class indexmat():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, input: typing.List[indexmat]) -> None: ...
    @typing.overload
    def __init__(self, numberofrows: int, numberofcolumns: int) -> None: ...
    @typing.overload
    def __init__(self, numberofrows: int, numberofcolumns: int, init: int, step: int) -> None: ...
    @typing.overload
    def __init__(self, numberofrows: int, numberofcolumns: int, initvalue: int) -> None: ...
    @typing.overload
    def __init__(self, numberofrows: int, numberofcolumns: int, valvec: typing.List[int]) -> None: ...
    def count(self) -> int: ...
    def countcolumns(self) -> int: ...
    def countrows(self) -> int: ...
    def print(self) -> None: ...
    def printsize(self) -> None: ...
    pass
class integration():
    pass
class mat():
    def __add__(self, arg0: mat) -> mat: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, matsize: int, rowaddresses: indexmat, coladdresses: indexmat, vals: densemat) -> None: ...
    @typing.overload
    def __init__(self, myformulation: formulation, rowaddresses: indexmat, coladdresses: indexmat, vals: densemat) -> None: ...
    @typing.overload
    def __mul__(self, arg0: float) -> mat: ...
    @typing.overload
    def __mul__(self, arg0: mat) -> mat: ...
    @typing.overload
    def __mul__(self, arg0: vec) -> vec: ...
    def __neg__(self) -> mat: ...
    def __pos__(self) -> mat: ...
    def __rmul__(self, arg0: float) -> mat: ...
    def __sub__(self, arg0: mat) -> mat: ...
    def __truediv__(self, arg0: float) -> mat: ...
    def copy(self) -> mat: ...
    def countcolumns(self) -> int: ...
    def countnnz(self) -> int: ...
    def countrows(self) -> int: ...
    def getainds(self) -> indexmat: ...
    def getdinds(self) -> indexmat: ...
    def print(self) -> None: ...
    def reusefactorization(self) -> None: ...
    pass
class mesh():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, inputshapes: typing.List[shape], globalgeometryskin: int, numoverlaplayers: int, verbosity: int = 1) -> None: ...
    @typing.overload
    def __init__(self, inputshapes: typing.List[shape], verbosity: int = 1) -> None: ...
    @typing.overload
    def __init__(self, mergeduplicates: bool, meshfiles: typing.List[str], verbosity: int = 1) -> None: ...
    @typing.overload
    def __init__(self, name: str, globalgeometryskin: int, numoverlaplayers: int, verbosity: int = 1) -> None: ...
    @typing.overload
    def __init__(self, name: str, verbosity: int = 1) -> None: ...
    def getdimension(self) -> int: ...
    def getdimensions(self) -> typing.List[float]: ...
    def getphysicalregionnumbers(self, dim: int = -1) -> typing.List[int]: ...
    @typing.overload
    def load(self, inputshapes: typing.List[shape], globalgeometryskin: int, numoverlaplayers: int, verbosity: int = 1) -> None: ...
    @typing.overload
    def load(self, inputshapes: typing.List[shape], verbosity: int = 1) -> None: ...
    @typing.overload
    def load(self, mergeduplicates: bool, meshfiles: typing.List[str], verbosity: int = 1) -> None: ...
    @typing.overload
    def load(self, name: str, globalgeometryskin: int, numoverlaplayers: int, verbosity: int = 1) -> None: ...
    @typing.overload
    def load(self, name: str, verbosity: int = 1) -> None: ...
    @typing.overload
    def move(self, physreg: int, u: expression) -> None: ...
    @typing.overload
    def move(self, u: expression) -> None: ...
    def printdimensions(self) -> typing.List[float]: ...
    @typing.overload
    def rotate(self, physreg: int, x: float, y: float, z: float) -> None: ...
    @typing.overload
    def rotate(self, x: float, y: float, z: float) -> None: ...
    @typing.overload
    def scale(self, physreg: int, x: float, y: float, z: float) -> None: ...
    @typing.overload
    def scale(self, x: float, y: float, z: float) -> None: ...
    @typing.overload
    def selectanynode(self, newphysreg: int) -> None: ...
    @typing.overload
    def selectanynode(self, newphysreg: int, physregtoselectfrom: int) -> None: ...
    @typing.overload
    def selectbox(self, newphysreg: int, physregtobox: int, selecteddim: int, boxlimit: typing.List[float]) -> None: ...
    @typing.overload
    def selectbox(self, newphysreg: int, selecteddim: int, boxlimit: typing.List[float]) -> None: ...
    @typing.overload
    def selectexclusion(self, newphysreg: int, physregstoexclude: typing.List[int]) -> None: ...
    @typing.overload
    def selectexclusion(self, newphysreg: int, physregtoexcludefrom: int, physregstoexclude: typing.List[int]) -> None: ...
    @typing.overload
    def selectlayer(self, newphysreg: int, physregtoselectfrom: int, physregtostartgrowth: int, numlayers: int) -> None: ...
    @typing.overload
    def selectlayer(self, newphysreg: int, physregtostartgrowth: int, numlayers: int) -> None: ...
    @typing.overload
    def selectskin(self, newphysreg: int) -> None: ...
    @typing.overload
    def selectskin(self, newphysreg: int, physregtoskin: int) -> None: ...
    @typing.overload
    def selectsphere(self, newphysreg: int, physregtosphere: int, selecteddim: int, centercoords: typing.List[float], radius: float) -> None: ...
    @typing.overload
    def selectsphere(self, newphysreg: int, selecteddim: int, centercoords: typing.List[float], radius: float) -> None: ...
    def setadaptivity(self, criterion: expression, lownumsplits: int, highnumsplits: int) -> None: ...
    @typing.overload
    def shift(self, physreg: int, x: float, y: float, z: float) -> None: ...
    @typing.overload
    def shift(self, x: float, y: float, z: float) -> None: ...
    def split(self, n: int = 1) -> None: ...
    def use(self) -> None: ...
    def write(self, name: str, verbosity: int = 1) -> None: ...
    pass
class parameter():
    @typing.overload
    def __add__(self, arg0: float) -> expression: ...
    @typing.overload
    def __add__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, numrows: int, numcols: int) -> None: ...
    @typing.overload
    def __mul__(self, arg0: float) -> expression: ...
    @typing.overload
    def __mul__(self, arg0: parameter) -> expression: ...
    def __neg__(self) -> expression: ...
    def __pos__(self) -> expression: ...
    def __radd__(self, arg0: float) -> expression: ...
    def __rmul__(self, arg0: float) -> expression: ...
    def __rsub__(self, arg0: float) -> expression: ...
    def __rtruediv__(self, arg0: float) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: float) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: parameter) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: parameter) -> expression: ...
    def atbarycenter(self, physreg: int, onefield: field) -> vec: ...
    def countcolumns(self) -> int: ...
    def countrows(self) -> int: ...
    @typing.overload
    def integrate(self, physreg: int, integrationorder: int) -> float: ...
    @typing.overload
    def integrate(self, physreg: int, meshdeform: expression, integrationorder: int) -> float: ...
    @typing.overload
    def interpolate(self, physreg: int, meshdeform: expression, xyzcoord: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def interpolate(self, physreg: int, meshdeform: expression, xyzcoord: typing.List[float], interpolated: typing.List[float], isfound: typing.List[bool]) -> None: ...
    @typing.overload
    def interpolate(self, physreg: int, xyzcoord: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def interpolate(self, physreg: int, xyzcoord: typing.List[float], interpolated: typing.List[float], isfound: typing.List[bool]) -> None: ...
    @typing.overload
    def max(self, physreg: int, meshdeform: expression, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def max(self, physreg: int, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def min(self, physreg: int, meshdeform: expression, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    @typing.overload
    def min(self, physreg: int, refinement: int, xyzrange: typing.List[float] = []) -> typing.List[float]: ...
    def print(self) -> None: ...
    def setvalue(self, physreg: int, input: expression) -> None: ...
    @typing.overload
    def write(self, physreg: int, filename: str, lagrangeorder: int, numtimesteps: int = -1) -> None: ...
    @typing.overload
    def write(self, physreg: int, meshdeform: expression, filename: str, lagrangeorder: int, numtimesteps: int = -1) -> None: ...
    @typing.overload
    def write(self, physreg: int, numfftharms: int, filename: str, lagrangeorder: int) -> None: ...
    @typing.overload
    def write(self, physreg: int, numfftharms: int, meshdeform: expression, filename: str, lagrangeorder: int) -> None: ...
    pass
class port():
    @typing.overload
    def __add__(self, arg0: float) -> expression: ...
    @typing.overload
    def __add__(self, arg0: port) -> expression: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, harmonicnumbers: typing.List[int]) -> None: ...
    @typing.overload
    def __mul__(self, arg0: float) -> expression: ...
    @typing.overload
    def __mul__(self, arg0: port) -> expression: ...
    def __neg__(self) -> expression: ...
    def __pos__(self) -> expression: ...
    def __radd__(self, arg0: float) -> expression: ...
    def __rmul__(self, arg0: float) -> expression: ...
    def __rsub__(self, arg0: float) -> expression: ...
    def __rtruediv__(self, arg0: float) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: float) -> expression: ...
    @typing.overload
    def __sub__(self, arg0: port) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: float) -> expression: ...
    @typing.overload
    def __truediv__(self, arg0: port) -> expression: ...
    def cos(self, freqindex: int) -> port: ...
    def getharmonics(self) -> typing.List[int]: ...
    def getname(self) -> str: ...
    def getvalue(self) -> float: ...
    @typing.overload
    def harmonic(self, harmonicnumber: int) -> port: ...
    @typing.overload
    def harmonic(self, harmonicnumbers: typing.List[int]) -> port: ...
    def print(self) -> None: ...
    def setname(self, name: str) -> None: ...
    def setvalue(self, portval: float) -> None: ...
    def sin(self, freqindex: int) -> port: ...
    pass
class shape():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, shapename: str, physreg: int, centercoords: typing.List[float], radius: float, nummeshpts: int) -> None: ...
    @typing.overload
    def __init__(self, shapename: str, physreg: int, centerpoint: shape, radius: float, nummeshpts: int) -> None: ...
    @typing.overload
    def __init__(self, shapename: str, physreg: int, coords: typing.List[float]) -> None: ...
    @typing.overload
    def __init__(self, shapename: str, physreg: int, coords: typing.List[float], nummeshpts: int) -> None: ...
    @typing.overload
    def __init__(self, shapename: str, physreg: int, coords: typing.List[float], nummeshpts: typing.List[int]) -> None: ...
    @typing.overload
    def __init__(self, shapename: str, physreg: int, subshapes: typing.List[shape]) -> None: ...
    @typing.overload
    def __init__(self, shapename: str, physreg: int, subshapes: typing.List[shape], nummeshpts: int) -> None: ...
    @typing.overload
    def __init__(self, shapename: str, physreg: int, subshapes: typing.List[shape], nummeshpts: typing.List[int]) -> None: ...
    def duplicate(self) -> shape: ...
    @typing.overload
    def extrude(self, physreg: int, height: float, numlayers: int, extrudedirection: typing.List[float] = [0.0, 0.0, 1.0]) -> shape: ...
    @typing.overload
    def extrude(self, physreg: typing.List[int], height: typing.List[float], numlayers: typing.List[int], extrudedirection: typing.List[float] = [0.0, 0.0, 1.0]) -> typing.List[shape]: ...
    def getcoords(self) -> typing.List[float]: ...
    def getcurvatureorder(self) -> int: ...
    def getdimension(self) -> int: ...
    def getname(self) -> str: ...
    def getphysicalregion(self) -> int: ...
    def getsons(self) -> typing.List[shape]: ...
    def move(self, u: expression) -> None: ...
    def rotate(self, alphax: float, alphay: float, alphaz: float) -> None: ...
    def scale(self, scalex: float, scaley: float, scalez: float) -> None: ...
    def setphysicalregion(self, physreg: int) -> None: ...
    def shift(self, shiftx: float, shifty: float, shiftz: float) -> None: ...
    pass
class spanningtree():
    def __init__(self, physregs: typing.List[int]) -> None: ...
    def countedgesintree(self) -> int: ...
    def write(self, filename: str) -> None: ...
    pass
class spline():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, filename: str, delimiter: str = '\n') -> None: ...
    @typing.overload
    def __init__(self, xin: typing.List[float], yin: typing.List[float]) -> None: ...
    @typing.overload
    def evalat(self, input: densemat) -> densemat: ...
    @typing.overload
    def evalat(self, input: float) -> float: ...
    @typing.overload
    def evalat(self, input: typing.List[float]) -> typing.List[float]: ...
    def getderivative(self) -> spline: ...
    def getxmax(self) -> float: ...
    def getxmin(self) -> float: ...
    def set(self, xin: typing.List[float], yin: typing.List[float]) -> None: ...
    def write(self, filename: str, numsplits: int, delimiter: str = '\n') -> None: ...
    pass
class universe():
    @staticmethod
    def getmaxnumthreads() -> int: ...
    @staticmethod
    def setmaxnumthreads(mnt: int) -> None: ...
    maxnumthreads = -1
    roundoffnoiselevel = 1e-10
    pass
class vec():
    def __add__(self, arg0: vec) -> vec: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, formul: formulation) -> None: ...
    @typing.overload
    def __init__(self, vecsize: int, addresses: indexmat, vals: densemat) -> None: ...
    def __mul__(self, arg0: float) -> vec: ...
    def __neg__(self) -> vec: ...
    def __or__(self, arg0: field) -> vectorfieldselect: ...
    def __pos__(self) -> vec: ...
    def __rmul__(self, arg0: float) -> vec: ...
    def __sub__(self, arg0: vec) -> vec: ...
    def __truediv__(self, arg0: float) -> vec: ...
    def copy(self) -> vec: ...
    def getallvalues(self) -> densemat: ...
    @typing.overload
    def getvalue(self, address: int) -> float: ...
    @typing.overload
    def getvalue(self, prt: port) -> float: ...
    def getvalues(self, addresses: indexmat) -> densemat: ...
    def load(self, filename: str) -> None: ...
    def noautomaticupdate(self) -> None: ...
    def norm(self, type: str = '2') -> float: ...
    def permute(self, rowpermute: indexmat, invertit: bool = False) -> None: ...
    def print(self) -> None: ...
    def setallvalues(self, valsmat: densemat, op: str = 'set') -> None: ...
    @typing.overload
    def setdata(self) -> None: ...
    @typing.overload
    def setdata(self, physreg: int, myfield: field, op: str = 'set') -> None: ...
    @typing.overload
    def setvalue(self, address: int, value: float, op: str = 'set') -> None: ...
    @typing.overload
    def setvalue(self, prt: port, value: float, op: str = 'set') -> None: ...
    def setvalues(self, addresses: indexmat, valsmat: densemat, op: str = 'set') -> None: ...
    def size(self) -> int: ...
    def sum(self) -> float: ...
    def updateconstraints(self) -> None: ...
    def write(self, filename: str) -> None: ...
    pass
class vectorfieldselect():
    def setdata(self, physreg: int, myfield: field, op: str = 'set') -> None: ...
    pass
class wallclock():
    def __init__(self) -> None: ...
    def pause(self) -> None: ...
    def print(self, toprint: str = '') -> None: ...
    def resume(self) -> None: ...
    def tic(self) -> None: ...
    def toc(self) -> float: ...
    pass
def abs(input: expression) -> expression:
    pass
def acos(input: expression) -> expression:
    pass
def adapt(verbosity: int = 0) -> bool:
    pass
def alladapt(verbosity: int = 0) -> bool:
    pass
@typing.overload
def allgather(fragment: typing.List[float], gathered: typing.List[float]) -> None:
    pass
@typing.overload
def allgather(fragment: typing.List[float], gathered: typing.List[float], fragsizes: typing.List[int]) -> None:
    pass
@typing.overload
def allgather(fragment: typing.List[int], gathered: typing.List[int]) -> None:
    pass
@typing.overload
def allgather(fragment: typing.List[int], gathered: typing.List[int], fragsizes: typing.List[int]) -> None:
    pass
def allpartition(meshfile: str) -> str:
    pass
def andpositive(exprs: typing.List[expression]) -> expression:
    pass
def array1x1(arg0: expression) -> expression:
    pass
def array1x2(arg0: expression, arg1: expression) -> expression:
    pass
def array1x3(arg0: expression, arg1: expression, arg2: expression) -> expression:
    pass
def array2x1(arg0: expression, arg1: expression) -> expression:
    pass
def array2x2(arg0: expression, arg1: expression, arg2: expression, arg3: expression) -> expression:
    pass
def array2x3(arg0: expression, arg1: expression, arg2: expression, arg3: expression, arg4: expression, arg5: expression) -> expression:
    pass
def array3x1(arg0: expression, arg1: expression, arg2: expression) -> expression:
    pass
def array3x2(arg0: expression, arg1: expression, arg2: expression, arg3: expression, arg4: expression, arg5: expression) -> expression:
    pass
def array3x3(arg0: expression, arg1: expression, arg2: expression, arg3: expression, arg4: expression, arg5: expression, arg6: expression, arg7: expression, arg8: expression) -> expression:
    pass
def asin(input: expression) -> expression:
    pass
def atan(input: expression) -> expression:
    pass
def barrier() -> None:
    pass
@typing.overload
def broadcast(broadcaster: int, data: typing.List[float]) -> None:
    pass
@typing.overload
def broadcast(broadcaster: int, data: typing.List[int]) -> None:
    pass
def comp(selectedcomp: int, input: expression) -> expression:
    pass
def compx(input: expression) -> expression:
    pass
def compy(input: expression) -> expression:
    pass
def compz(input: expression) -> expression:
    pass
@typing.overload
def continuitycondition(gamma1: int, gamma2: int, u1: field, u2: field, lagmultorder: int, errorifnotfound: bool = True) -> typing.List[integration]:
    pass
@typing.overload
def continuitycondition(gamma1: int, gamma2: int, u1: field, u2: field, rotcent: typing.List[float], rotangz: float, angzmod: float, factor: float, lagmultorder: int) -> typing.List[integration]:
    pass
def cos(input: expression) -> expression:
    pass
def count() -> int:
    pass
def crossproduct(a: expression, b: expression) -> expression:
    pass
def curl(input: expression) -> expression:
    pass
def dbtoneper(toconvert: expression) -> expression:
    pass
def determinant(input: expression) -> expression:
    pass
def div(input: expression) -> expression:
    pass
@typing.overload
def dof(input: expression) -> expression:
    pass
@typing.overload
def dof(input: expression, physreg: int) -> expression:
    pass
def doubledotproduct(a: expression, b: expression) -> expression:
    pass
def dt(input: expression) -> expression:
    pass
def dtdt(input: expression) -> expression:
    pass
def dtdtdt(input: expression) -> expression:
    pass
def dtdtdtdt(input: expression) -> expression:
    pass
def dx(input: expression) -> expression:
    pass
def dy(input: expression) -> expression:
    pass
def dz(input: expression) -> expression:
    pass
def entry(row: int, col: int, input: expression) -> expression:
    pass
@typing.overload
def exchange(targetranks: typing.List[int], sends: typing.List[typing.List[float]], receives: typing.List[typing.List[float]]) -> None:
    pass
@typing.overload
def exchange(targetranks: typing.List[int], sends: typing.List[typing.List[int]], receives: typing.List[typing.List[int]]) -> None:
    pass
@typing.overload
def exchange(targetranks: typing.List[int], sendvalues: typing.List[float], receivevalues: typing.List[float]) -> None:
    pass
@typing.overload
def exchange(targetranks: typing.List[int], sendvalues: typing.List[int], receivevalues: typing.List[int]) -> None:
    pass
def exp(input: expression) -> expression:
    pass
def eye(size: int) -> expression:
    pass
def fieldorder(input: field, alpha: float = -1.0, absthres: float = 0.0) -> expression:
    pass
def finalize() -> None:
    pass
@typing.overload
def gather(gatherer: int, fragment: typing.List[float], gathered: typing.List[float]) -> None:
    pass
@typing.overload
def gather(gatherer: int, fragment: typing.List[float], gathered: typing.List[float], fragsizes: typing.List[int]) -> None:
    pass
@typing.overload
def gather(gatherer: int, fragment: typing.List[int], gathered: typing.List[int]) -> None:
    pass
@typing.overload
def gather(gatherer: int, fragment: typing.List[int], gathered: typing.List[int], fragsizes: typing.List[int]) -> None:
    pass
def getharmonic(harmnum: int, input: expression, numfftharms: int = -1) -> expression:
    pass
def getmaxnumthreads() -> int:
    pass
def getpi() -> float:
    pass
def getrandom() -> float:
    pass
def getrank() -> int:
    pass
def getsubversion() -> int:
    pass
def gettime() -> float:
    pass
@typing.overload
def gettotalforce(physreg: int, EorH: expression, epsilonormu: expression, extraintegrationorder: int = 0) -> typing.List[float]:
    pass
@typing.overload
def gettotalforce(physreg: int, meshdeform: expression, EorH: expression, epsilonormu: expression, extraintegrationorder: int = 0) -> typing.List[float]:
    pass
def getversion() -> int:
    pass
def getversionname() -> str:
    pass
def grad(input: expression) -> expression:
    pass
def greenlagrangestrain(input: expression) -> expression:
    pass
@typing.overload
def grouptimesteps(filename: str, fileprefix: str, firstint: int, timevals: typing.List[float]) -> None:
    pass
@typing.overload
def grouptimesteps(filename: str, filestogroup: typing.List[str], timevals: typing.List[float]) -> None:
    pass
def ifpositive(condexpr: expression, trueexpr: expression, falseexpr: expression) -> expression:
    pass
def initialize() -> None:
    pass
@typing.overload
def integral(physreg: int, meshdeform: expression, tointegrate: expression, integrationorderdelta: int = 0, blocknumber: int = 0) -> integration:
    pass
@typing.overload
def integral(physreg: int, numcoefharms: int, meshdeform: expression, tointegrate: expression, integrationorderdelta: int = 0, blocknumber: int = 0) -> integration:
    pass
@typing.overload
def integral(physreg: int, numcoefharms: int, tointegrate: expression, integrationorderdelta: int = 0, blocknumber: int = 0) -> integration:
    pass
@typing.overload
def integral(physreg: int, tointegrate: expression, integrationorderdelta: int = 0, blocknumber: int = 0) -> integration:
    pass
def inverse(input: expression) -> expression:
    pass
def isavailable() -> bool:
    pass
def isdefined(physreg: int) -> bool:
    pass
def isempty(physreg: int) -> bool:
    pass
def isinside(physregtocheck: int, physreg: int) -> bool:
    pass
def istouching(physregtocheck: int, physreg: int) -> bool:
    pass
def linspace(a: float, b: float, num: int) -> typing.List[float]:
    pass
def loadshape(meshfile: str) -> typing.List[typing.List[shape]]:
    pass
def loadvector(filename: str, delimiter: str = ',', sizeincluded: bool = False) -> typing.List[float]:
    pass
def log10(input: expression) -> expression:
    pass
def logspace(a: float, b: float, num: int, basis: float = 10.0) -> typing.List[float]:
    pass
def makeharmonic(harms: typing.List[int], exprs: typing.List[expression]) -> expression:
    pass
@typing.overload
def max(a: expression, b: expression) -> expression:
    pass
@typing.overload
def max(a: field, b: field) -> expression:
    pass
@typing.overload
def max(a: parameter, b: parameter) -> expression:
    pass
@typing.overload
def max(data: typing.List[float]) -> None:
    pass
@typing.overload
def max(data: typing.List[int]) -> None:
    pass
def meshsize(integrationorder: int) -> expression:
    pass
@typing.overload
def min(a: expression, b: expression) -> expression:
    pass
@typing.overload
def min(a: field, b: field) -> expression:
    pass
@typing.overload
def min(a: parameter, b: parameter) -> expression:
    pass
def mod(input: expression, modval: float) -> expression:
    pass
def moveharmonic(origharms: typing.List[int], destharms: typing.List[int], input: expression, numfftharms: int = -1) -> expression:
    pass
def norm(arg0: expression) -> expression:
    pass
@typing.overload
def normal() -> expression:
    pass
@typing.overload
def normal(pointoutofphysreg: int) -> expression:
    pass
@typing.overload
def on(physreg: int, coordshift: expression, expression: expression, errorifnotfound: bool = True) -> expression:
    pass
@typing.overload
def on(physreg: int, expression: expression, errorifnotfound: bool = True) -> expression:
    pass
def orpositive(exprs: typing.List[expression]) -> expression:
    pass
def periodicitycondition(gamma1: int, gamma2: int, u: field, dat1: typing.List[float], dat2: typing.List[float], factor: float, lagmultorder: int) -> typing.List[integration]:
    pass
def pow(base: expression, exponent: expression) -> expression:
    pass
def predefinedacousticradiation(dofp: expression, tfp: expression, soundspeed: expression, neperattenuation: expression) -> expression:
    pass
def predefinedacoustics(dofp: expression, tfp: expression, soundspeed: expression, neperattenuation: expression) -> expression:
    pass
def predefinedacousticstructureinteraction(dofp: expression, tfp: expression, dofu: expression, tfu: expression, soundspeed: expression, fluiddensity: expression, normal: expression, neperattenuation: expression, scaling: float = 1.0) -> expression:
    pass
def predefinedadvectiondiffusion(doff: expression, tff: expression, v: expression, alpha: expression, beta: expression, gamma: expression, isdivvzero: bool = True) -> expression:
    pass
def predefineddiffusion(doff: expression, tff: expression, alpha: expression, beta: expression) -> expression:
    pass
@typing.overload
def predefinedelasticity(dofu: expression, tfu: expression, Eyoung: expression, nupoisson: expression, myoption: str = '') -> expression:
    pass
@typing.overload
def predefinedelasticity(dofu: expression, tfu: expression, elasticitymatrix: expression, myoption: str = '') -> expression:
    pass
@typing.overload
def predefinedelasticity(dofu: expression, tfu: expression, u: field, Eyoung: expression, nupoisson: expression, prestress: expression, myoption: str = '') -> expression:
    pass
@typing.overload
def predefinedelasticity(dofu: expression, tfu: expression, u: field, elasticitymatrix: expression, prestress: expression, myoption: str = '') -> expression:
    pass
def predefinedelectrostaticforce(input: expression, E: expression, epsilon: expression) -> expression:
    pass
def predefinedmagnetostaticforce(input: expression, H: expression, mu: expression) -> expression:
    pass
def predefinednavierstokes(dofv: expression, tfv: expression, v: expression, dofp: expression, tfp: expression, mu: expression, rho: expression, dtrho: expression, gradrho: expression, includetimederivs: bool = False, isdensityconstant: bool = True, isviscosityconstant: bool = True) -> expression:
    pass
def predefinedstabilization(stabtype: str, delta: expression, f: expression, v: expression, diffusivity: expression, residual: expression) -> expression:
    pass
def predefinedstokes(dofv: expression, tfv: expression, dofp: expression, tfp: expression, mu: expression, rho: expression, dtrho: expression, gradrho: expression, includetimederivs: bool = False, isdensityconstant: bool = True, isviscosityconstant: bool = True) -> expression:
    pass
@typing.overload
def printtotalforce(physreg: int, EorH: expression, epsilonormu: expression, extraintegrationorder: int = 0) -> typing.List[float]:
    pass
@typing.overload
def printtotalforce(physreg: int, meshdeform: expression, EorH: expression, epsilonormu: expression, extraintegrationorder: int = 0) -> typing.List[float]:
    pass
@typing.overload
def printvector(input: typing.List[bool]) -> None:
    pass
@typing.overload
def printvector(input: typing.List[float]) -> None:
    pass
@typing.overload
def printvector(input: typing.List[int]) -> None:
    pass
def printversion() -> None:
    pass
@typing.overload
def receive(source: int, tag: int, data: typing.List[float]) -> None:
    pass
@typing.overload
def receive(source: int, tag: int, data: typing.List[int]) -> None:
    pass
@typing.overload
def scatter(scatterer: int, toscatter: typing.List[float], fragment: typing.List[float]) -> None:
    pass
@typing.overload
def scatter(scatterer: int, toscatter: typing.List[float], fragment: typing.List[float], fragsizes: typing.List[int]) -> None:
    pass
@typing.overload
def scatter(scatterer: int, toscatter: typing.List[int], fragment: typing.List[int]) -> None:
    pass
@typing.overload
def scatter(scatterer: int, toscatter: typing.List[int], fragment: typing.List[int], fragsizes: typing.List[int]) -> None:
    pass
def scatterwrite(filename: str, xcoords: typing.List[float], ycoords: typing.List[float], zcoords: typing.List[float], compxevals: typing.List[float], compyevals: typing.List[float] = [], compzevals: typing.List[float] = []) -> None:
    pass
def selectall() -> int:
    pass
def selectintersection(physregs: typing.List[int]) -> int:
    pass
def selectunion(physregs: typing.List[int]) -> int:
    pass
@typing.overload
def send(destination: int, tag: int, data: typing.List[float]) -> None:
    pass
@typing.overload
def send(destination: int, tag: int, data: typing.List[int]) -> None:
    pass
def setaxisymmetry() -> None:
    pass
def setdata(invec: vec) -> None:
    pass
def setfundamentalfrequency(f: float) -> None:
    pass
def setmaxnumthreads(mnt: int) -> None:
    pass
def setphysicalregionshift(shiftamount: int) -> None:
    pass
def settime(t: float) -> None:
    pass
@typing.overload
def settimederivative(dtx: vec) -> None:
    pass
@typing.overload
def settimederivative(dtx: vec, dtdtx: vec) -> None:
    pass
def sin(input: expression) -> expression:
    pass
@typing.overload
def solve(A: mat, b: typing.List[vec], soltype: str = 'lu') -> typing.List[vec]:
    pass
@typing.overload
def solve(A: mat, b: vec, sol: vec, relrestol: float, maxnumit: int, soltype: str = 'bicgstab', precondtype: str = 'sor', verbosity: int = 1, diagscaling: bool = False) -> None:
    pass
@typing.overload
def solve(A: mat, b: vec, soltype: str = 'lu', diagscaling: bool = False) -> vec:
    pass
def sqrt(input: expression) -> expression:
    pass
def strain(input: expression) -> expression:
    pass
@typing.overload
def sum(data: typing.List[float]) -> None:
    pass
@typing.overload
def sum(data: typing.List[int]) -> None:
    pass
def t() -> expression:
    pass
def tan(input: expression) -> expression:
    pass
def tangent() -> expression:
    pass
@typing.overload
def tf(input: expression) -> expression:
    pass
@typing.overload
def tf(input: expression, physreg: int) -> expression:
    pass
def trace(a: expression) -> expression:
    pass
def transpose(input: expression) -> expression:
    pass
def vonmises(stress: expression) -> expression:
    pass
def writeshapefunctions(filename: str, sftypename: str, elementtypenumber: int, maxorder: int, allorientations: bool = False) -> None:
    pass
def writevector(filename: str, towrite: typing.List[float], delimiter: str = ',', writesize: bool = False) -> None:
    pass
def zienkiewiczzhu(input: expression) -> expression:
    pass
